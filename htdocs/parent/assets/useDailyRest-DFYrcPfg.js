import{c as T,q as h,s as l,J as k,$ as _}from"./main-piTIAPSx.js";import{u as q}from"./useQuery-Dbdyc74j.js";import{u as D}from"./useMutation-B8vlA97s.js";import{f as g,s as S}from"./format-VbeFDANp.js";import{e as W,a as G}from"./endOfWeek-BL7NObWT.js";import{p as L}from"./parseISO-JZi9Nyn6.js";/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const z=T("Moon",[["path",{d:"M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z",key:"a7tn18"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const j=T("Sun",[["circle",{cx:"12",cy:"12",r:"4",key:"4exip2"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"m4.93 4.93 1.41 1.41",key:"149t6j"}],["path",{d:"m17.66 17.66 1.41 1.41",key:"ptbguv"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"m6.34 17.66-1.41 1.41",key:"1m8zz5"}],["path",{d:"m19.07 4.93-1.41 1.41",key:"1shlcs"}]]),i={MAX_DAILY_WORKING_TIME:13,MAX_DAILY_DRIVING_TIME:9,MAX_DAILY_DRIVING_TIME_EXTENDED:10,MAX_WEEKLY_WORKING_TIME:60,MAX_WEEKLY_DRIVING_TIME:56,BREAK_AFTER_4_5_HOURS:45,BREAK_AFTER_6_HOURS:30,BREAK_AFTER_9_HOURS:45,DAILY_REST:11,REDUCED_DAILY_REST:9,WEEKLY_REST:45,MAX_FORTNIGHTLY_DRIVING_TIME:90},J=()=>{const{profile:e}=h();return q({queryKey:["today-time-entry",e==null?void 0:e.id],queryFn:async()=>{if(!(e!=null&&e.id))throw new Error("User profile is required");const r=new Date().toISOString().split("T")[0],{data:t,error:s}=await l.from("time_entries").select("*").eq("driver_id",e.id).eq("entry_date",r).single();if(s&&s.code!=="PGRST116")throw s;return t},enabled:!!(e!=null&&e.id)})},K=(e,r)=>{const{profile:t}=h();return q({queryKey:["time-entries",t==null?void 0:t.id,e,r],queryFn:async()=>{if(!(t!=null&&t.id))throw new Error("User profile is required");let s=l.from("time_entries").select("*").eq("driver_id",t.id).order("entry_date",{ascending:!1});const{data:a,error:n}=await s;if(n)throw n;return a||[]},enabled:!!(t!=null&&t.id)})},Z=()=>{const{profile:e}=h(),r=k();return D({mutationFn:async t=>{if(!(e!=null&&e.id))throw new Error("User profile is required");const s=new Date().toISOString().split("T")[0],a=new Date().toISOString(),{data:n}=await l.from("time_entries").select("id").eq("driver_id",e.id).eq("entry_date",s).single();if(n)throw new Error("Already clocked in today");const{data:o,error:y}=await l.from("time_entries").insert({driver_id:e.id,entry_date:s,clock_in_time:a,location_clock_in:t||"Unknown",status:"active"}).select().single();if(y)throw y;return o},onSuccess:()=>{r.invalidateQueries({queryKey:["today-time-entry"]}),r.invalidateQueries({queryKey:["time-entries"]}),_.success("Successfully clocked in")},onError:t=>{_.error("Failed to clock in: "+t.message)}})},ee=()=>{const{profile:e}=h(),r=k();return D({mutationFn:async t=>{if(!(e!=null&&e.id))throw new Error("User profile is required");const s=new Date().toISOString().split("T")[0],a=new Date().toISOString(),{data:n,error:o}=await l.from("time_entries").update({clock_out_time:a,location_clock_out:t||"Unknown",status:"completed"}).eq("driver_id",e.id).eq("entry_date",s).eq("status","active").select().single();if(o)throw o;return n},onSuccess:()=>{r.invalidateQueries({queryKey:["today-time-entry"]}),r.invalidateQueries({queryKey:["time-entries"]}),_.success("Successfully clocked out")},onError:t=>{_.error("Failed to clock out: "+t.message)}})},te=()=>{const{profile:e}=h(),r=k();return D({mutationFn:async()=>{if(!(e!=null&&e.id))throw new Error("User profile is required");const t=new Date().toISOString().split("T")[0],s=new Date().toISOString(),{data:a,error:n}=await l.from("time_entries").update({break_start_time:s}).eq("driver_id",e.id).eq("entry_date",t).eq("status","active").select().single();if(n)throw n;return a},onSuccess:()=>{r.invalidateQueries({queryKey:["today-time-entry"]}),_.success("Break started")},onError:t=>{_.error("Failed to start break: "+t.message)}})},re=()=>{const{profile:e}=h(),r=k();return D({mutationFn:async()=>{if(!(e!=null&&e.id))throw new Error("User profile is required");const t=new Date().toISOString().split("T")[0],s=new Date().toISOString(),{data:a,error:n}=await l.from("time_entries").update({break_end_time:s}).eq("driver_id",e.id).eq("entry_date",t).eq("status","active").select().single();if(n)throw n;return a},onSuccess:()=>{r.invalidateQueries({queryKey:["today-time-entry"]}),_.success("Break ended")},onError:t=>{_.error("Failed to end break: "+t.message)}})},se=()=>{const{data:e=[]}=K();return(()=>{const t=e.reduce((n,o)=>o.total_hours?n+o.total_hours:n,0),s=e.reduce((n,o)=>o.overtime_hours?n+o.overtime_hours:n,0),a=e.reduce((n,o)=>o.break_hours?n+o.break_hours:n,0);return{totalHours:t,totalOvertime:s,totalBreaks:a,averageHoursPerDay:e.length>0?t/e.length:0,totalDays:e.length}})()},ne=()=>{const{profile:e}=h();return q({queryKey:["time-off-requests",e==null?void 0:e.id],queryFn:async()=>{if(!(e!=null&&e.id))throw new Error("User profile is required");const{data:r,error:t}=await l.from("time_off_requests").select("*").eq("driver_id",e.id).order("created_at",{ascending:!1});if(t)throw t;return r||[]},enabled:!!(e!=null&&e.id)})},ie=()=>{const{profile:e}=h(),r=k();return D({mutationFn:async t=>{if(!(e!=null&&e.id))throw new Error("User profile is required");const{data:s,error:a}=await l.from("time_off_requests").insert({...t,driver_id:e.id,status:"pending"}).select().single();if(a)throw a;return s},onSuccess:()=>{r.invalidateQueries({queryKey:["time-off-requests"]}),_.success("Time off request submitted successfully")},onError:t=>{_.error("Failed to submit time off request: "+t.message)}})},N=(e,r=new Date)=>{const t=[],s=[],a=g(r,"yyyy-MM-dd"),n=e.filter(d=>d.entry_date&&d.entry_date===a),o=S(r,{weekStartsOn:1}),y=W(r,{weekStartsOn:1}),w=e.filter(d=>{if(!d.entry_date)return!1;try{const E=L(d.entry_date);return E>=o&&E<=y}catch{return console.warn("Invalid entry_date format:",d.entry_date),!1}}),u=n.reduce((d,E)=>d+(E.total_hours||0),0),m=n.reduce((d,E)=>d+(E.driving_hours||0),0),M=n.reduce((d,E)=>d+(E.break_hours||0),0);u>i.MAX_DAILY_WORKING_TIME?s.push(`Daily working time (${u}h) exceeds limit (${i.MAX_DAILY_WORKING_TIME}h)`):u>i.MAX_DAILY_WORKING_TIME-1&&t.push(`Daily working time (${u}h) approaching limit (${i.MAX_DAILY_WORKING_TIME}h)`),m>i.MAX_DAILY_DRIVING_TIME?s.push(`Daily driving time (${m}h) exceeds limit (${i.MAX_DAILY_DRIVING_TIME}h)`):m>i.MAX_DAILY_DRIVING_TIME-.5&&t.push(`Daily driving time (${m}h) approaching limit (${i.MAX_DAILY_DRIVING_TIME}h)`);const I=w.reduce((d,E)=>d+(E.total_hours||0),0),c=w.reduce((d,E)=>d+(E.driving_hours||0),0);I>i.MAX_WEEKLY_WORKING_TIME?s.push(`Weekly working time (${I}h) exceeds limit (${i.MAX_WEEKLY_WORKING_TIME}h)`):I>i.MAX_WEEKLY_WORKING_TIME-2&&t.push(`Weekly working time (${I}h) approaching limit (${i.MAX_WEEKLY_WORKING_TIME}h)`),c>i.MAX_WEEKLY_DRIVING_TIME?s.push(`Weekly driving time (${c}h) exceeds limit (${i.MAX_WEEKLY_DRIVING_TIME}h)`):c>i.MAX_WEEKLY_DRIVING_TIME-2&&t.push(`Weekly driving time (${c}h) approaching limit (${i.MAX_WEEKLY_DRIVING_TIME}h)`);const f=Y(u,M),v=X(u,M),A=C(),p=F(),O=b({dailyWorkingTime:u,dailyDrivingTime:m,weeklyWorkingTime:I,weeklyDrivingTime:c,breakCompliance:f,restCompliance:A});return{dailyWorkingTime:u,dailyDrivingTime:m,dailyBreaks:M,dailyRest:0,dailyCompliance:u<=i.MAX_DAILY_WORKING_TIME&&m<=i.MAX_DAILY_DRIVING_TIME,dailyWarnings:t.filter(d=>d.includes("Daily")),weeklyWorkingTime:I,weeklyDrivingTime:c,weeklyRest:0,weeklyCompliance:I<=i.MAX_WEEKLY_WORKING_TIME&&c<=i.MAX_WEEKLY_DRIVING_TIME,weeklyWarnings:t.filter(d=>d.includes("Weekly")),breakCompliance:f,requiredBreaks:R(u),takenBreaks:M,breakWarnings:v,restCompliance:A,restWarnings:p,overallCompliance:s.length===0,complianceScore:O,criticalViolations:s,warnings:t}},Y=(e,r)=>{const t=R(e);return r>=t},R=e=>e<=4.5?0:e<=6?i.BREAK_AFTER_4_5_HOURS/60:e<=9?i.BREAK_AFTER_6_HOURS/60:i.BREAK_AFTER_9_HOURS/60,X=(e,r)=>{const t=[],s=R(e);return e>4.5&&r<s&&t.push(`Break time (${r}h) is less than required (${s}h) for ${e}h of work`),e>6&&r<i.BREAK_AFTER_6_HOURS/60&&t.push("Additional break required after 6 hours of work"),t},C=(e,r)=>!0,F=(e,r)=>[],b=e=>{let r=100;return e.dailyWorkingTime>i.MAX_DAILY_WORKING_TIME?r-=20:e.dailyWorkingTime>i.MAX_DAILY_WORKING_TIME-1&&(r-=5),e.dailyDrivingTime>i.MAX_DAILY_DRIVING_TIME?r-=20:e.dailyDrivingTime>i.MAX_DAILY_DRIVING_TIME-.5&&(r-=5),e.weeklyWorkingTime>i.MAX_WEEKLY_WORKING_TIME?r-=15:e.weeklyWorkingTime>i.MAX_WEEKLY_WORKING_TIME-2&&(r-=5),e.weeklyDrivingTime>i.MAX_WEEKLY_DRIVING_TIME?r-=15:e.weeklyDrivingTime>i.MAX_WEEKLY_DRIVING_TIME-2&&(r-=5),e.breakCompliance||(r-=10),Math.max(0,r)},ae=(e=new Date)=>{const{data:r=[]}=K();return{analysis:N(r,e),limits:i}},oe=(e,r)=>{const{profile:t}=h();return q({queryKey:["daily-rest",t==null?void 0:t.id,e==null?void 0:e.toISOString(),r==null?void 0:r.toISOString()],queryFn:async()=>{if(!(t!=null&&t.id))throw new Error("User profile is required");let s=l.from("daily_rest").select("*").eq("driver_id",t.id).order("rest_date",{ascending:!1});const{data:a,error:n}=await s;if(n){if(console.error("Error fetching daily rest:",n),n.code==="PGRST205"||n.code==="42P01")return console.warn("daily_rest table not found, returning empty data"),[];throw n}return a||[]},enabled:!!(t!=null&&t.id)})},U=()=>{const{profile:e}=h(),r=k();return D({mutationFn:async t=>{if(!(e!=null&&e.id)||!(e!=null&&e.organization_id))throw new Error("User profile and organization information required");const{data:s,error:a}=await l.from("daily_rest").insert({...t,driver_id:e.id,organization_id:e.organization_id}).select().single();if(a)throw a.code==="PGRST205"||a.code==="42P01"?(console.warn("daily_rest table not found, cannot create rest record"),new Error("Daily rest table not found. Please ensure the database is properly set up.")):a;return s},onSuccess:()=>{r.invalidateQueries({queryKey:["daily-rest"]}),r.invalidateQueries({queryKey:["schedules"]}),_.success("Daily rest recorded successfully")},onError:t=>{console.error("Error creating daily rest:",t),_.error("Failed to record daily rest: "+t.message)}})},de=()=>{const{profile:e}=h(),r=k(),t=U();return D({mutationFn:async s=>{if(!(e!=null&&e.id))throw new Error("User profile is required");const a=G({start:s.startDate,end:s.endDate}),{data:n,error:o}=await l.from("time_entries").select("entry_date").eq("driver_id",e.id).gte("entry_date",g(s.startDate,"yyyy-MM-dd")).lte("entry_date",g(s.endDate,"yyyy-MM-dd"));o&&console.warn("Error fetching time entries:",o);const{data:y,error:w}=await l.from("daily_rest").select("rest_date").eq("driver_id",e.id).gte("rest_date",g(s.startDate,"yyyy-MM-dd")).lte("rest_date",g(s.endDate,"yyyy-MM-dd"));w&&(w.code==="PGRST205"||w.code==="42P01")&&console.warn("daily_rest table not found, treating as no existing rest records");const u=new Set((n==null?void 0:n.map(c=>c.entry_date))||[]),m=new Set((y==null?void 0:y.map(c=>c.rest_date))||[]),M=a.filter(c=>{const f=g(c,"yyyy-MM-dd");return!u.has(f)&&!m.has(f)}),I=M.map(c=>{const f=g(c,"yyyy-MM-dd");return t.mutateAsync({rest_date:f,rest_type:"daily_rest",duration_hours:24,notes:"Automatically recorded rest day - no work activity"})});return await Promise.all(I),{daysProcessed:a.length,restDaysCreated:M.length,workedDays:u.size,existingRestDays:m.size}},onSuccess:s=>{r.invalidateQueries({queryKey:["daily-rest"]}),r.invalidateQueries({queryKey:["schedules"]}),r.invalidateQueries({queryKey:["time-entries"]}),s.restDaysCreated>0?_.success(`Automatically recorded ${s.restDaysCreated} rest days`):_.info("No new rest days to record")},onError:s=>{console.error("Error auto-recording rest days:",s),_.error("Failed to auto-record rest days: "+s.message)}})},B=e=>{const{profile:r}=h(),t=W(e,{weekStartsOn:1});return q({queryKey:["weekly-rest-summary",r==null?void 0:r.id,e.toISOString()],queryFn:async()=>{if(!(r!=null&&r.id))throw new Error("User profile is required");const s=g(e,"yyyy-MM-dd"),a=g(t,"yyyy-MM-dd"),{data:n,error:o}=await l.from("time_entries").select("entry_date, total_hours").eq("driver_id",r.id).gte("entry_date",s).lte("entry_date",a);o&&console.warn("Error fetching time entries for weekly summary:",o);const{data:y,error:w}=await l.from("daily_rest").select("rest_date, rest_type, duration_hours").eq("driver_id",r.id).gte("rest_date",s).lte("rest_date",a);w&&(w.code==="PGRST205"||w.code==="42P01")&&console.warn("daily_rest table not found, treating as no rest records");const u=(n==null?void 0:n.length)||0,m=(y==null?void 0:y.length)||0,M=(n==null?void 0:n.reduce((c,f)=>c+(f.total_hours||0),0))||0,I=(y==null?void 0:y.reduce((c,f)=>c+(f.duration_hours||0),0))||0;return{weekStart:e,weekEnd:t,workedDays:u,restDays:m,totalWorkHours:M,totalRestHours:I,averageWorkHoursPerDay:u>0?M/u:0,averageRestHoursPerDay:m>0?I/m:0}},enabled:!!(r!=null&&r.id)})},ce=()=>{const e=S(new Date,{weekStartsOn:1});return B(e)};export{z as M,j as S,K as a,ne as b,se as c,ae as d,Z as e,ee as f,te as g,re as h,ie as i,de as j,oe as k,ce as l,J as u};
